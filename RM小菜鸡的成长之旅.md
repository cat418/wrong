# RM小菜鸡的成长之旅

## 关于.gitignore

\#.gitignore是一个文本文件,用于告诉Git忽略某些文件或目录，使其不会被提交到版本库中 排除不需要版本控制的文件 如:系统临时文件，IDE文件，环境配置文件，依赖缓存文件,密钥文件等。

作用:减小代码库体积，保护隐私信息

==常见的规则:==

``` c++
example.log 	//忽略example.log文件
node/  			//忽略特定目录
*.log 			//忽略所有拓展名的文件
tmp/*   		//匹配tmp目录下所有文件和文件夹    
.env   			//忽略本地环境文件
logs/*
!logs/work      //忽略logs目录下的所有文件,但会保留logs/work
```

## 关于镜像

#在Docker中，镜像是一个包含了应用程序及其依赖环境的只读模版。镜像用来创建容器，容器是镜像的运行实例。

**镜像是轻量级的打包单元**：它包含了操作系统、依赖环境、配置文件、应用程序代码等。

**镜像是静态的**：它是只读的，无法直接修改。

容器是基于镜像实例化出来的，可以理解为“镜像的运行环境”。

镜像本身并不占用内存，只占用磁盘存储空间。[内存和存储空间的区别](#内存和存储空间的区别)



![镜像和容器的区别](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/5.png)

![不同的镜像类型](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/3.png)

## 关于Docker

#Docker是一个开源的容器化平台，通过创建容器打包依赖项，确保代码能在任何开发环境中一致的运行。

除了Docker还有Podman等容器化平台，有兴趣可查看下表

![image-20241208100254159](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/2.png)

## 关于Dckerfile



## 关于内存和存储空间的区别

![区别](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/1.png)

## 关于生命周期问题

刚入队时，学长总提醒我们代码编写要考虑到生命周期的问题，所以生命周期到底是什么呢？ 🤔

#代码的生命周期是从代码创建到最终退役的完整过程。

![作用](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/4.png)

## 关于ROS

[学习网站](https://docs.ros.org/en/jazzy/Installation.html)

#在 ROS（Robot Operating System）中，`package.xml` 是描述软件包（package）元数据的配置文件。每个 ROS 软件包都有一个 `package.xml` 文件，用于定义该软件包的基本信息、依赖关系和其他元数据。

`package.xml` 是 ROS 软件包的重要组成部分，CMake 和 ROS 工具在编译和运行时都会参考这个文件。

#**定义软件包信息**：
包括软件包的名称、版本、描述、维护者信息等。

**声明依赖关系**：
明确该软件包依赖于哪些其他 ROS 软件包或系统库。

**提供工具支持**：
用于 `rosdep` 工具进行依赖管理，自动安装依赖。

**方便软件包的发现**：
其他用户或 ROS 工具可以通过 `package.xml` 确定一个软件包的功能或依赖信息。

## 关于linux指令

``` c++
ls -a //列出所有文件，包括隐藏文件
```

## 关于 #include <eigen3/Eigen/Core>

Eigen是一个有效支持线性代数，矩阵和矢量运算，数值分析及其相关的算法的C ++开源库.

### 矩阵和向量的定义

``` c++
#include <eigen3/Eigen/Core>
#include <iostream>

int main() {
    // 定义一个固定大小的 3x3 矩阵
    Eigen::Matrix3d mat; // 相当于 Eigen::Matrix<double, 3, 3>
    mat << 1, 2, 3,
           4, 5, 6,
           7, 8, 9;

    // 输出矩阵
    std::cout << "Matrix:\n" << mat << std::endl;
    return 0;
}
```

#### 1.动态大小矩阵

``` c++
#include <eigen3/Eigen/Core>
#include <iostream>

int main() {
    // 动态大小矩阵
    Eigen::MatrixXd mat(2, 3); // 2 行 3 列
    mat << 1, 2, 3,
           4, 5, 6;

    std::cout << "Dynamic Matrix:\n" << mat << std::endl;
    return 0;
}
```

#### 2.向量定义

``` c++
#include <eigen3/Eigen/Core>
#include <iostream>

int main() {
    // 静态大小向量
    Eigen::Vector3d vec(1, 2, 3); // 3 维向量

    // 动态大小向量
    Eigen::VectorXd dynamic_vec(4);
    dynamic_vec << 1, 2, 3, 4;

    std::cout << "Static Vector:\n" << vec << std::endl;
    std::cout << "Dynamic Vector:\n" << dynamic_vec << std::endl;
    return 0;
}
```

想详细了解请参考这个文档：

[Eigen库的学习](https://blog.csdn.net/m0_63111108/article/details/124949608)



## 关于相机的畸变系数矩阵

#可以用Mat或者vector<double>表示.

但是后者更加灵活，如下对比：

``` c++
cv::Mat distCoeffs = (cv::Mat_<double>(1, 5) << k1, k2, p1, p2, k3);
std::vector<double> distCoeffs = {k1, k2, p1, p2, k3};
```

二者的相互转换：

``` c++
std::vector<double> distVec;
distCoeffs.copyTo(distVec); // distCoeffs 是 cv::Mat 类型
cv::Mat distCoeffs(distVec); // distVec 是 std::vector<double> 类型
```



## 关于相机句柄

#指代一个用于访问和控制相机硬件的对象。通过编程接口与相机设备进行交互的方式。，它可以代表一个打开的相机设备，程序可以通过该句柄来获取相机的数据流、配置设置、获取图像或视频帧。这个句柄通常是一个整数值或对象，程序通过它进行相机的初始化、设置（如分辨率、曝光时间等），以及数据捕捉。如opencv中的VideoCapture返回的对象可以视为相机句柄。

## 关于一些不懂得词

### 1.echo

打印文本或变量的值 ;在编程和脚本中，`echo` 也常用于显示信息或调试。

### 2.shell

在操作系统中，**Shell** 是用户与操作系统内核之间的接口，主要用来解释用户的命令，并与内核进行交互。它既是一种命令解释器，又是一个强大的脚本编程语言环境。

### 3.欧拉角

1.俯仰角(pitch):绕物体的横向轴（y轴）旋转的角度。

2.偏航角(Yaw):绕物体的垂直轴(z轴)旋转的角度。

3.滚转角(Roll):绕物体的纵向轴(x轴)旋转的角度。

缺点："万向锁"当俯仰角接近+-90度时，旋转轴的自由度减少，导致欧拉角无法唯一描述旋转.

### 4.四元数

#表示三维空间的旋转  可以避免欧拉角万向节死锁的问题 在opencv中常用于旋转和姿态表示 

### 5.static constexpr

#静态常量表达式   `constexpr` 变量在程序运行时不会更改，且编译器会尽量在编译阶段进行求值。

### 6.launch和yaml ,py, xml

#launch是一个用于启动多个节点及其相关资源的机制 ,定义启动节点，设置参数，配置发布/订阅关系等

launch配置分为三种格式:xml,yaml和 py

1. **Python 格式 (`.py`)**：目前 ROS 2 推荐使用 Python 编写的 `launch` 文件。Python 格式的启动文件具有更强的灵活性和可扩展性。
2. **XML 格式 (`.launch`)**：在 ROS 1 中常见，ROS 2 支持的格式较少使用。
3. **YAML (`.yaml`)**:YAML（YAML Ain't Markup Language）是一种人类可读的数据序列化格式，经常用于配置文件中。在 ROS 2 中，YAML 文件通常用于存储和加载节点参数、传感器配置等。

### 7.UI和GUI和CLI

UI：用户界面，用户与设备，应用程序或系统之间的交互界面

GUI:UI的一个子集，特指通过图形和图像来与计算机系统交互的界面

CLI:命令行界面

### 8.inline

#内联函数：请求编译器将函数的代码直接插入到调用点，避免传统函数调用的开销(如：压栈，跳转) 用于简单，频繁调用的小函数

### 9.[[nodiscard]]

#告诉编译器函数返回值不应该被忽略，如果没有返回值，编译器会发出警告

## 关于动态库和静态库

### 1. **编译和链接时机**

- 静态库
  - **编译时链接**：静态库是在 **编译时** 链接到程序中的，库的代码会被复制到最终的可执行文件中。
  - **使用方式**：在编译过程中，程序的链接器会将静态库的代码拷贝到可执行文件中，生成独立的、完整的程序文件。
- 动态库
  - **运行时链接**：动态库是在 **运行时** 被加载，程序在启动时或运行时通过操作系统动态地加载所需的库文件。
  - **使用方式**：程序并不包含动态库的代码，而是包含了链接到动态库的路径和符号。程序运行时，操作系统负责加载动态库并将其链接到程序。

### 2. **文件类型**

- **静态库**：通常是 `.a`（在 Linux 和 macOS 中）或 `.lib`（在 Windows 中）的文件。
- **动态库**：通常是 `.so`（在 Linux 中），`.dll`（在 Windows 中），或 `.dylib`（在 macOS 中）的文件。

### 3. **文件大小**

- 静态库
  - 由于库的代码被嵌入到最终的可执行文件中，生成的可执行文件通常比较大。
- 动态库
  - 可执行文件通常较小，因为它只包含动态库的符号信息，并不会包含库的实际代码。
  - 动态库文件本身较小，多个程序可以共享同一个动态库，避免了重复存储库的代码。

### 4. **运行时依赖性**

- 静态库

  - 程序 **不依赖于外部库文件**，因为库的代码已经在编译时被嵌入到可执行文件中。运行时不需要额外的库文件。
  - 如果静态库的代码发生变化，需要 **重新编译** 依赖该库的程序。
  
- 动态库

  - 程序 **依赖于外部库文件**，在运行时需要加载相应的动态库。如果动态库缺失或版本不匹配，程序可能无法启动或执行。
- 动态库的更新不需要重新编译依赖的程序，只需替换库文件即可，前提是新库与旧库兼容。

### 5. **内存使用**

- 静态库

  - 每个程序都会 **独立加载** 静态库的代码。即使多个程序使用相同的静态库，它们也会各自拥有一份库的副本，占用额外的内存。

- 动态库

  - 动态库 **只加载一次**，多个程序可以共享同一份动态库代码。这样可以节省内存资源，尤其是当多个程序需要使用相同的库时。

### 6. **更新和维护**

- 静态库

  - 静态库更新时，必须 **重新编译** 依赖该库的所有程序。因为静态库的代码已经编译进程序，程序和库是紧密绑定的。

- 动态库

  - 动态库更新时，只需要 **替换库文件**，而无需重新编译依赖该库的程序。只要接口（函数、类等）保持一致，程序可以直接使用新的动态库。

### 7. **性能**

- 静态库

  - 由于静态库的代码已经被嵌入到可执行文件中，因此程序启动和运行时 **不需要进行额外的库加载**。因此，静态库通常提供 **较快的启动性能**。

- 动态库

  - 动态库在程序启动时需要 **加载和链接**，这可能会导致程序启动的时间稍微变长。
- 然而，动态库能够被多个程序共享，这对于长时间运行的程序而言，内存的节省和灵活性非常重要。

### 8. **依赖管理**

- 静态库

  - 静态库的依赖通常在编译时就已经明确，无需在程序运行时去查找和链接。
  - 程序不容易出现由于库版本不匹配引起的运行时错误。
  
- 动态库

  - 程序对动态库的依赖比较高。需要保证在运行时能够找到动态库，且确保库的版本与程序兼容。
- 可能出现 **"依赖地狱"** 问题，即不同版本的库可能会引发兼容性问题，或者某些库缺失导致程序无法运行。

### 9. **共享与复用**

- **静态库**：
  - 静态库是 **不可共享的**，每个程序都有自己独立的静态库副本。
  - 静态库更适合不希望外部共享的场景，或者不希望在运行时依赖外部文件的场景。
- **动态库**：
  - 动态库可以被 **多个程序共享**。操作系统将会将动态库加载到内存中，并允许多个程序使用它，从而减少内存使用。
  - 动态库适合开发大型应用程序和系统，其中多个程序需要共享同一库的代码。

### 10. **兼容性**

- 静态库

  - 静态库链接的过程中，库的所有符号都被复制到程序中，运行时没有版本依赖问题，但需要更新时重新编译。
- 动态库

  - 动态库的兼容性要求较高，库的接口（函数签名等）必须保持不变。如果库的接口发生变化，依赖该库的程序可能会因为找不到某些符号而崩溃。

## 关于QT

选择一个模版：

Application(QT):这个模板用于创建一个基于 Qt 框架的应用程序。它是 C++ 编写的 Qt 应用程序.

Application(QT for Python):适用于 Python 的 QT

Library:该模板用于创建一个库项目，通常是静态库（.a）或动态库（.so 或 .dll）。你可以将其用作其他 Qt 项目的依赖。

其他项目:这个选项为一些特殊项目类型提供模板，如创建 QML 文件、测试工具、UI 组件等。

Non-Qt Project:这个模板允许你创建不依赖 Qt 框架的项目。它适用于你不想使用 Qt 库的 C++ 项目。

Import Project:此选项用于将现有的外部项目导入到 Qt Creator 中。通常用于导入现有的 CMake 或 qmake 项目。

Files and CLasses:这个选项允许你只创建新的文件或类，而不创建完整的项目。通常用于添加新的源文件、头文件、UI 文件、类或其他模块。

---

Qt WIdgets Application:这是一个基于 Qt Widgets 库的桌面应用程序模板，适用于传统的图形用户界面 (GUI) 应用。它为你创建了一个带有 Qt Widgets 的应用程序结构，通常使用 `.ui` 文件来设计界面。

Qt Console Application:这是一个没有图形界面的应用程序模板，适用于开发命令行工具或后台服务等。

Qt Quick Application:这是一个基于 Qt Quick 和 QML 的应用程序模板，适用于现代的 UI 开发，尤其是用于移动设备和嵌入式平台。这个模板生成的应用程序使用 QML 来定义界面，适合开发具有动态和流畅界面的应用。

---

==**qmake**==: `qmake` 是 Qt 官方提供的构建工具，它专门为 Qt 项目设计，帮助用户生成 Makefile 文件，从而完成编译和构建过程。

**特点:**

**Qt 专用**：qmake 是为 Qt 开发设计的，特别适合构建基于 Qt 的应用。

**简化配置**：通过 `.pro` 文件配置项目，`.pro` 文件通常包含源文件、头文件、资源文件等信息。qmake 会根据这些文件生成 Makefile。

**自动生成构建配置**：qmake 处理大多数 Qt 项目的构建配置，用户只需要指定项目的基本信息，它会自动处理 Qt 库的路径和编译器设置。

**跨平台**：qmake 支持跨平台构建，但它的跨平台能力不如 CMake 灵活，特别是在非 Qt 环境下。

==**cmake:**== 是一个跨平台的开源构建工具，它不仅可以用于 Qt 项目，也可以用于其他各种类型的 C++ 项目。它生成的构建文件支持不同的平台和工具链，比如 Makefile、Visual Studio 项目文件等。

**特点:**

- **更强的跨平台支持**：CMake 具备更强的跨平台支持，能处理多种编译器和平台（Windows、Linux、macOS等）。它生成的构建系统（Makefile、Ninja、Visual Studio等）可以根据目标平台自动适应。
- **灵活性**：CMake 提供了更多的灵活性，适合大型项目和多语言项目。它支持复杂的依赖管理、外部库集成、构建选项等。
- **Qt 支持**：CMake 自 3.0 版本起内置了对 Qt 项目的支持，可以直接处理 Qt 的模块、资源文件、UI 文件等。
- **与多种构建系统兼容**：CMake 可以生成适用于各种平台和构建工具的构建文件。

==**Qbs:**==`Qbs`（Qt Build Suite）是 Qt 开发团队推出的一种构建系统，旨在简化跨平台构建过程。它是一个声明性构建工具，特别适用于复杂的 Qt 项目。

## 关于卡尔曼滤波

**(KF)标准卡尔曼滤波:**适用于线性系统，假设系统状态和测量模型都是线性关系，且噪声为高斯分布。通过矩阵运算实现递归更新。

**(EKF)扩展卡尔曼滤波:**适用于弱非线性系统。对非线性系统进行一阶泰勒展开（线性化），近似处理非线性部分，预测和更新阶段基于线性化的雅可比矩阵计算。

**(UKF)无迹卡尔曼滤波:**适用于**强非线性系统**。通过引入无迹变换（Unscented Transform），对状态分布进行采样并传播，直接处理非线性，而无需线性化。对非线性问题的近似比EKF更精确。

---

​						measure				    

​						    |(H)

 						   V

state->predict->pre_state->update->state(再把state传回去)

卡尔曼滤波的本质是：数据融合

---

扩展卡尔曼滤波器模版类（Ekf）:

``` c++
#include <eigen3/Eigen/Core>
#include <iostream>


// 卡尔曼 State_NUM：状态量的数量 Measure_NUM:观测量的数量 规定几*几 
template<int State_NUM, int Measure_NUM>
class Ekf {
public:
    //状态转移矩阵
    typedef Eigen::Matrix<double, State_NUM, State_NUM> F;
    //测量矩阵
    typedef Eigen::Matrix<double, Measure_NUM, State_NUM> H;
    //状态的雅可比矩阵
    typedef Eigen::Matrix<double, State_NUM, State_NUM> FJacobi;
    //测量的雅可比矩阵
    typedef Eigen::Matrix<double, Measure_NUM, State_NUM> HJacobi;
    //过程噪声协方差矩阵
    typedef Eigen::Matrix<double, State_NUM, State_NUM> Q;
    //测量噪声协方差矩阵
    typedef Eigen::Matrix<double, Measure_NUM, Measure_NUM> R;
    //状态协方差矩阵
    typedef Eigen::Matrix<double, State_NUM, State_NUM> P;
    //状态向量
    typedef Eigen::Matrix<double, 1, State_NUM> State;
    //测量向量
    typedef Eigen::Matrix<double, 1, Measure_NUM> Measurement;
	//构造函数 初始化Ekf对象
    Ekf(F f, H h, FJacobi f_j, HJacobi h_j, Q q, R r, P p):
        m_f(f),
        m_h(h),
        m_f_jacobi(f_j),
        m_h_jacobi(h_j),
        m_q(q),
        m_r(r),
        m_p(p){
            std::cout << "init successfully" << std::endl;
    }
    //设置滤波的初始状态向量
    void initState(State init_state) {
        m_state = init_state;
    }
//卡尔曼滤波的五个重要公式
    void predict() {
        // 1.预测下一个状态
        m_pre_state = m_f * m_state;

        // 2.预测状态协方差矩阵
        m_pre_p = m_f * m_p * m_f.transpose() + m_q;
    }
//更新步骤
    void update(Measurement measurement) {
        // 3.计算卡尔曼增益
        m_k =  m_pre_p * m_h.transpose() * ((m_h * m_pre_p * m_h.transpose() + m_r).inverse());
        //4.更新状态
        m_state = m_pre_state + m_k * (measurement - h(m_pre_p));
        // 5.更新协方差
        Eigen::MatrixXd I = Eigen::MatrixXd::Identity(m_p.rows(), m_p.cols());
        m_p = (I - m_k * m_h) * m_pre_p;
    }
//提供访问当前状态向量和协方差矩阵的接口
    State getState() {return m_state;}
    P getP() {return m_p;}
    //虚析构函数
    virtual ~Ekf();
private:
    F m_f;
    H m_h;
    FJacobi m_f_jacobi;
    HJacobi m_h_jacobi;
    Q m_q;
    R m_r;
    P m_p;
    P m_pre_p;
    State m_state;
    State m_pre_state;
    //动态大小矩阵类型 存储卡尔曼增益矩阵
    Eigen::MatrixXd m_k;
    Measurement m_measurement;
};
```

## 关于虚函数

==特性:==

1. **运行时动态绑定**
   - 普通成员函数在编译时绑定（静态绑定），调用的是指针或引用的静态类型的成员函数。
   - 虚函数在运行时绑定（动态绑定），调用的是对象的实际类型（动态类型）的成员函数。
2. **虚函数表（vtable）机制**
   - 每个含有虚函数的类会生成一个 **虚函数表（vtable）**，存储该类所有虚函数的地址。
   - 每个对象内部含有一个指向虚函数表的指针（vptr），用于调用动态类型对应的虚函数。
3. **支持继承和多态**
   - 当基类定义虚函数，派生类可以重写它。
   - 使用基类指针或引用操作派生类对象时，调用的函数由对象的实际类型决定。
4. **虚函数的开销**
   - 虚函数引入了一定的运行时开销，包括额外的内存存储（vtable 和 vptr）和动态函数调用的时间。

**==将析构函数写成虚函数==**:

将析构函数定义为**虚函数**的目的是为了支持 **多态行为**，确保当类被继承时，删除派生类对象时能够正确调用派生类和基类的析构函数，避免资源泄漏。

如果基类的析构函数不是虚函数，当使用基类指针删除派生类对象时，只会调用基类的析构函数，派生类的析构函数不会被调用。这会导致派生类中分配的资源未被正确释放。

**==构造函数不能写成虚函数:==**

虚函数依赖于虚函数表，而虚函数表的指针只有在对象的构造过程中才会被设置。

如果构造函数是虚函数，就会涉及一个矛盾——构造函数需要依赖 vtable 的初始化，而 vtable 的初始化又依赖于构造函数的执行。

**==先验后验:==**

***先验***:是基于上一时刻的状态估计和系统的预测模型，对当前状态的预测估计。

***后验估计:***是在结合测量值后，对系统状态的修正。

**==多态性:==**是面向对象编程的一个核心特性,它允许不同类型的对象，以统一的接口操作，从而实现代码的灵活性和可扩展性.

***编译时多态***：通过函数重载和运算符重载实现，函数的调用在编译时决定。

***运行时多态***:通过继承和虚函数实现，函数的调用在运行时决定，运行时多态依赖 **动态绑定**，即根据对象的实际类型调用对应的方法。

## 强枚举和传统枚举

#==强枚举：==enum class 

特征：

**作用域控制：**强枚举的成员不会自动暴露到外部作用域，必须通过枚举名进行限定。

**类型安全：**枚举值不能隐式转换为整数类型，必须显示转换。

**底层类型可指定：**可以明确指定枚举的底层类型，来优化存储或与特定的接口兼容。

#==传统枚举：==

特征：

**没有作用域:**枚举值直接暴露在枚举定义所在的作用域中，可能导致命名冲突。

**允许隐式转换：**枚举值可以隐式转换为整数类型，而不需要显示转换

**不能指定底层类型**： 弱枚举的底层类型固定为 `int`（实现可能不同），无法指定其他类型。

**类型安全性较低**： 弱枚举没有类型限制，不同枚举类型的值可以相互赋值，这可能导致逻辑错误。

## const的使用情况

**防止参数被意外修改：**将参数声明为`const`可以确保在函数内部不会无意中修改参数的值。

 **允许传递只读参数：**如果函数声明参数为`const`引用，它就可以接受非常量和常量参数，而不需要额外的重载。

**性能优化：**避免拷贝大对象，对于非基础类型（例如自定义类或容器），传递参数时通过`const`引用而不是值传递，避免了拷贝整个对象，从而提升性能。

 **增强代码意图表达：**将参数标记为`const`可以明确表明函数不会修改参数内容，帮助代码的维护者快速了解函数的意图。
