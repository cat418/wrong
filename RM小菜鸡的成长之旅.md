# RM小菜鸡的成长之旅

## 关于.gitignore

\#.gitignore是一个文本文件,用于告诉Git忽略某些文件或目录，使其不会被提交到版本库中 排除不需要版本控制的文件 如:系统临时文件，IDE文件，环境配置文件，依赖缓存文件,密钥文件等。

作用:减小代码库体积，保护隐私信息

==常见的规则:==

``` c++
example.log 	//忽略example.log文件
node/  			//忽略特定目录
*.log 			//忽略所有拓展名的文件
tmp/*   		//匹配tmp目录下所有文件和文件夹    
.env   			//忽略本地环境文件
logs/*
!logs/work      //忽略logs目录下的所有文件,但会保留logs/work
```

## 关于镜像

#在Docker中，镜像是一个包含了应用程序及其依赖环境的只读模版。镜像用来创建容器，容器是镜像的运行实例。

**镜像是轻量级的打包单元**：它包含了操作系统、依赖环境、配置文件、应用程序代码等。

**镜像是静态的**：它是只读的，无法直接修改。

容器是基于镜像实例化出来的，可以理解为“镜像的运行环境”。

镜像本身并不占用内存，只占用磁盘存储空间。[内存和存储空间的区别](#内存和存储空间的区别)



![镜像和容器的区别](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/5.png)

![不同的镜像类型](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/3.png)

## 关于Docker

#Docker是一个开源的容器化平台，通过创建容器打包依赖项，确保代码能在任何开发环境中一致的运行。

除了Docker还有Podman等容器化平台，有兴趣可查看下表

![image-20241208100254159](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/2.png)

## 关于Dckerfile



## 关于内存和存储空间的区别

![区别](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/1.png)

## 关于生命周期问题

刚入队时，学长总提醒我们代码编写要考虑到生命周期的问题，所以生命周期到底是什么呢？ 🤔

#代码的生命周期是从代码创建到最终退役的完整过程。

![作用](https://github.com/cat418/wrong/blob/main/%E5%B0%8F%E8%8F%9C%E9%B8%A1picture/4.png)

## 关于ROS

[学习网站](https://docs.ros.org/en/jazzy/Installation.html)

#在 ROS（Robot Operating System）中，`package.xml` 是描述软件包（package）元数据的配置文件。每个 ROS 软件包都有一个 `package.xml` 文件，用于定义该软件包的基本信息、依赖关系和其他元数据。

`package.xml` 是 ROS 软件包的重要组成部分，CMake 和 ROS 工具在编译和运行时都会参考这个文件。

#**定义软件包信息**：
包括软件包的名称、版本、描述、维护者信息等。

**声明依赖关系**：
明确该软件包依赖于哪些其他 ROS 软件包或系统库。

**提供工具支持**：
用于 `rosdep` 工具进行依赖管理，自动安装依赖。

**方便软件包的发现**：
其他用户或 ROS 工具可以通过 `package.xml` 确定一个软件包的功能或依赖信息。

## 关于linux指令

``` c++
ls -a //列出所有文件，包括隐藏文件
```

## 关于 #include <eigen3/Eigen/Core>

Eigen是一个有效支持线性代数，矩阵和矢量运算，数值分析及其相关的算法的C ++开源库.

### 矩阵和向量的定义

``` c++
#include <eigen3/Eigen/Core>
#include <iostream>

int main() {
    // 定义一个固定大小的 3x3 矩阵
    Eigen::Matrix3d mat; // 相当于 Eigen::Matrix<double, 3, 3>
    mat << 1, 2, 3,
           4, 5, 6,
           7, 8, 9;

    // 输出矩阵
    std::cout << "Matrix:\n" << mat << std::endl;
    return 0;
}
```

#### 1.动态大小矩阵

``` c++
#include <eigen3/Eigen/Core>
#include <iostream>

int main() {
    // 动态大小矩阵
    Eigen::MatrixXd mat(2, 3); // 2 行 3 列
    mat << 1, 2, 3,
           4, 5, 6;

    std::cout << "Dynamic Matrix:\n" << mat << std::endl;
    return 0;
}
```

#### 2.向量定义

``` c++
#include <eigen3/Eigen/Core>
#include <iostream>

int main() {
    // 静态大小向量
    Eigen::Vector3d vec(1, 2, 3); // 3 维向量

    // 动态大小向量
    Eigen::VectorXd dynamic_vec(4);
    dynamic_vec << 1, 2, 3, 4;

    std::cout << "Static Vector:\n" << vec << std::endl;
    std::cout << "Dynamic Vector:\n" << dynamic_vec << std::endl;
    return 0;
}
```

想详细了解请参考这个文档：

[Eigen库的学习](https://blog.csdn.net/m0_63111108/article/details/124949608)



## 关于相机的畸变系数矩阵

#可以用Mat或者vector<double>表示.

但是后者更加灵活，如下对比：

``` c++
cv::Mat distCoeffs = (cv::Mat_<double>(1, 5) << k1, k2, p1, p2, k3);
std::vector<double> distCoeffs = {k1, k2, p1, p2, k3};
```

二者的相互转换：

``` c++
std::vector<double> distVec;
distCoeffs.copyTo(distVec); // distCoeffs 是 cv::Mat 类型
cv::Mat distCoeffs(distVec); // distVec 是 std::vector<double> 类型
```



## 关于相机句柄

#指代一个用于访问和控制相机硬件的对象。通过编程接口与相机设备进行交互的方式。，它可以代表一个打开的相机设备，程序可以通过该句柄来获取相机的数据流、配置设置、获取图像或视频帧。这个句柄通常是一个整数值或对象，程序通过它进行相机的初始化、设置（如分辨率、曝光时间等），以及数据捕捉。如opencv中的VideoCapture返回的对象可以视为相机句柄。

## 关于一些不懂得词

### 1.echo

打印文本或变量的值 ;在编程和脚本中，`echo` 也常用于显示信息或调试。

### 2.shell

在操作系统中，**Shell** 是用户与操作系统内核之间的接口，主要用来解释用户的命令，并与内核进行交互。它既是一种命令解释器，又是一个强大的脚本编程语言环境。

### 3.欧拉角

1.俯仰角(pitch):绕物体的横向轴（y轴）旋转的角度。

2.偏航角(Yaw):绕物体的垂直轴(z轴)旋转的角度。

3.滚转角(Roll):绕物体的纵向轴(x轴)旋转的角度。

缺点："万向锁"当俯仰角接近+-90度时，旋转轴的自由度减少，导致欧拉角无法唯一描述旋转.

### 4.四元数

#表示三维空间的旋转  可以避免欧拉角万向节死锁的问题 在opencv中常用于旋转和姿态表示 

### 5.static constexpr

#静态常量表达式   `constexpr` 变量在程序运行时不会更改，且编译器会尽量在编译阶段进行求值。

### 6.launch和yaml ,py, xml

#launch是一个用于启动多个节点及其相关资源的机制 ,定义启动节点，设置参数，配置发布/订阅关系等

launch配置分为三种格式:xml,yaml和 py

1. **Python 格式 (`.py`)**：目前 ROS 2 推荐使用 Python 编写的 `launch` 文件。Python 格式的启动文件具有更强的灵活性和可扩展性。
2. **XML 格式 (`.launch`)**：在 ROS 1 中常见，ROS 2 支持的格式较少使用。
3. **YAML (`.yaml`)**:YAML（YAML Ain't Markup Language）是一种人类可读的数据序列化格式，经常用于配置文件中。在 ROS 2 中，YAML 文件通常用于存储和加载节点参数、传感器配置等。

### 7.UI和GUI和CLI

UI：用户界面，用户与设备，应用程序或系统之间的交互界面

GUI:UI的一个子集，特指通过图形和图像来与计算机系统交互的界面

CLI:命令行界面

## 关于动态库和静态库

### 1. **编译和链接时机**

- 静态库
  - **编译时链接**：静态库是在 **编译时** 链接到程序中的，库的代码会被复制到最终的可执行文件中。
  - **使用方式**：在编译过程中，程序的链接器会将静态库的代码拷贝到可执行文件中，生成独立的、完整的程序文件。
- 动态库
  - **运行时链接**：动态库是在 **运行时** 被加载，程序在启动时或运行时通过操作系统动态地加载所需的库文件。
  - **使用方式**：程序并不包含动态库的代码，而是包含了链接到动态库的路径和符号。程序运行时，操作系统负责加载动态库并将其链接到程序。

### 2. **文件类型**

- **静态库**：通常是 `.a`（在 Linux 和 macOS 中）或 `.lib`（在 Windows 中）的文件。
- **动态库**：通常是 `.so`（在 Linux 中），`.dll`（在 Windows 中），或 `.dylib`（在 macOS 中）的文件。

### 3. **文件大小**

- 静态库
  - 由于库的代码被嵌入到最终的可执行文件中，生成的可执行文件通常比较大。
- 动态库
  - 可执行文件通常较小，因为它只包含动态库的符号信息，并不会包含库的实际代码。
  - 动态库文件本身较小，多个程序可以共享同一个动态库，避免了重复存储库的代码。

### 4. **运行时依赖性**

- 静态库

  - 程序 **不依赖于外部库文件**，因为库的代码已经在编译时被嵌入到可执行文件中。运行时不需要额外的库文件。
  - 如果静态库的代码发生变化，需要 **重新编译** 依赖该库的程序。
  
- 动态库

  - 程序 **依赖于外部库文件**，在运行时需要加载相应的动态库。如果动态库缺失或版本不匹配，程序可能无法启动或执行。
- 动态库的更新不需要重新编译依赖的程序，只需替换库文件即可，前提是新库与旧库兼容。

### 5. **内存使用**

- 静态库

  - 每个程序都会 **独立加载** 静态库的代码。即使多个程序使用相同的静态库，它们也会各自拥有一份库的副本，占用额外的内存。

- 动态库

  - 动态库 **只加载一次**，多个程序可以共享同一份动态库代码。这样可以节省内存资源，尤其是当多个程序需要使用相同的库时。

### 6. **更新和维护**

- 静态库

  - 静态库更新时，必须 **重新编译** 依赖该库的所有程序。因为静态库的代码已经编译进程序，程序和库是紧密绑定的。

- 动态库

  - 动态库更新时，只需要 **替换库文件**，而无需重新编译依赖该库的程序。只要接口（函数、类等）保持一致，程序可以直接使用新的动态库。

### 7. **性能**

- 静态库

  - 由于静态库的代码已经被嵌入到可执行文件中，因此程序启动和运行时 **不需要进行额外的库加载**。因此，静态库通常提供 **较快的启动性能**。

- 动态库

  - 动态库在程序启动时需要 **加载和链接**，这可能会导致程序启动的时间稍微变长。
- 然而，动态库能够被多个程序共享，这对于长时间运行的程序而言，内存的节省和灵活性非常重要。

### 8. **依赖管理**

- 静态库

  - 静态库的依赖通常在编译时就已经明确，无需在程序运行时去查找和链接。
  - 程序不容易出现由于库版本不匹配引起的运行时错误。
  
- 动态库

  - 程序对动态库的依赖比较高。需要保证在运行时能够找到动态库，且确保库的版本与程序兼容。
- 可能出现 **"依赖地狱"** 问题，即不同版本的库可能会引发兼容性问题，或者某些库缺失导致程序无法运行。

### 9. **共享与复用**

- **静态库**：
  - 静态库是 **不可共享的**，每个程序都有自己独立的静态库副本。
  - 静态库更适合不希望外部共享的场景，或者不希望在运行时依赖外部文件的场景。
- **动态库**：
  - 动态库可以被 **多个程序共享**。操作系统将会将动态库加载到内存中，并允许多个程序使用它，从而减少内存使用。
  - 动态库适合开发大型应用程序和系统，其中多个程序需要共享同一库的代码。

### 10. **兼容性**

- 静态库

  - 静态库链接的过程中，库的所有符号都被复制到程序中，运行时没有版本依赖问题，但需要更新时重新编译。
- 动态库

  - 动态库的兼容性要求较高，库的接口（函数签名等）必须保持不变。如果库的接口发生变化，依赖该库的程序可能会因为找不到某些符号而崩溃。

## 关于QT

选择一个模版：

Application(QT):这个模板用于创建一个基于 Qt 框架的应用程序。它是 C++ 编写的 Qt 应用程序.

Application(QT for Python):适用于 Python 的 QT

Library:该模板用于创建一个库项目，通常是静态库（.a）或动态库（.so 或 .dll）。你可以将其用作其他 Qt 项目的依赖。

其他项目:这个选项为一些特殊项目类型提供模板，如创建 QML 文件、测试工具、UI 组件等。

Non-Qt Project:这个模板允许你创建不依赖 Qt 框架的项目。它适用于你不想使用 Qt 库的 C++ 项目。

Import Project:此选项用于将现有的外部项目导入到 Qt Creator 中。通常用于导入现有的 CMake 或 qmake 项目。

Files and CLasses:这个选项允许你只创建新的文件或类，而不创建完整的项目。通常用于添加新的源文件、头文件、UI 文件、类或其他模块。

---

Qt WIdgets Application:这是一个基于 Qt Widgets 库的桌面应用程序模板，适用于传统的图形用户界面 (GUI) 应用。它为你创建了一个带有 Qt Widgets 的应用程序结构，通常使用 `.ui` 文件来设计界面。

Qt Console Application:这是一个没有图形界面的应用程序模板，适用于开发命令行工具或后台服务等。

Qt Quick Application:这是一个基于 Qt Quick 和 QML 的应用程序模板，适用于现代的 UI 开发，尤其是用于移动设备和嵌入式平台。这个模板生成的应用程序使用 QML 来定义界面，适合开发具有动态和流畅界面的应用。

---

**qmake**: `qmake` 是 Qt 官方提供的构建工具，它专门为 Qt 项目设计，帮助用户生成 Makefile 文件，从而完成编译和构建过程。

==特点:==

**Qt 专用**：qmake 是为 Qt 开发设计的，特别适合构建基于 Qt 的应用。

**简化配置**：通过 `.pro` 文件配置项目，`.pro` 文件通常包含源文件、头文件、资源文件等信息。qmake 会根据这些文件生成 Makefile。

**自动生成构建配置**：qmake 处理大多数 Qt 项目的构建配置，用户只需要指定项目的基本信息，它会自动处理 Qt 库的路径和编译器设置。

**跨平台**：qmake 支持跨平台构建，但它的跨平台能力不如 CMake 灵活，特别是在非 Qt 环境下。

**cmake:** 是一个跨平台的开源构建工具，它不仅可以用于 Qt 项目，也可以用于其他各种类型的 C++ 项目。它生成的构建文件支持不同的平台和工具链，比如 Makefile、Visual Studio 项目文件等。

==特点：==

- **更强的跨平台支持**：CMake 具备更强的跨平台支持，能处理多种编译器和平台（Windows、Linux、macOS等）。它生成的构建系统（Makefile、Ninja、Visual Studio等）可以根据目标平台自动适应。
- **灵活性**：CMake 提供了更多的灵活性，适合大型项目和多语言项目。它支持复杂的依赖管理、外部库集成、构建选项等。
- **Qt 支持**：CMake 自 3.0 版本起内置了对 Qt 项目的支持，可以直接处理 Qt 的模块、资源文件、UI 文件等。
- **与多种构建系统兼容**：CMake 可以生成适用于各种平台和构建工具的构建文件。

**Qbs:**`Qbs`（Qt Build Suite）是 Qt 开发团队推出的一种构建系统，旨在简化跨平台构建过程。它是一个声明性构建工具，特别适用于复杂的 Qt 项目。

#### 